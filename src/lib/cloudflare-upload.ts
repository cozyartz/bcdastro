// Cloudflare Upload Service - Direct uploads to R2, Stream, and Images
export interface CloudflareUploadConfig {
  accountId: string;
  apiToken: string;
  r2BucketName: string;
  streamCustomerCode: string;
  imagesAccountHash: string;
}

export interface UploadProgress {
  loaded: number;
  total: number;
  percentage: number;
}

export interface DirectUploadResponse {
  uploadURL: string;
  uid?: string; // For Stream uploads
  watermark?: {
    uid: string;
  };
}

export interface UploadResult {
  success: boolean;
  id: string;
  url: string;
  thumbnailUrl?: string;
  duration?: number;
  variants?: Array<{
    id: string;
    url: string;
  }>;
  error?: string;
}

export interface FileValidation {
  isValid: boolean;
  fileType: 'video' | 'image';
  error?: string;
  maxSize: number;
  supportedFormats: string[];
}

export class CloudflareUploadService {
  private config: CloudflareUploadConfig;
  private baseApiUrl = 'https://api.cloudflare.com/client/v4';

  constructor(config: CloudflareUploadConfig) {
    this.config = config;
  }

  /**
   * Validate file before upload
   */
  validateFile(file: File): FileValidation {
    const videoFormats = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'flv', 'wmv'];
    const imageFormats = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp'];
    
    const fileExtension = file.name.split('.').pop()?.toLowerCase() || '';
    const isVideo = file.type.startsWith('video/') || videoFormats.includes(fileExtension);
    const isImage = file.type.startsWith('image/') || imageFormats.includes(fileExtension);

    // File type validation
    if (!isVideo && !isImage) {
      return {
        isValid: false,
        fileType: 'image',
        error: 'Unsupported file format. Please upload video or image files.',
        maxSize: 0,
        supportedFormats: [...videoFormats, ...imageFormats]
      };
    }

    const fileType = isVideo ? 'video' : 'image';
    
    // Size validation
    const maxVideoSize = 30 * 1024 * 1024 * 1024; // 30GB for videos (R2/Stream)
    const maxImageSize = 100 * 1024 * 1024; // 100MB for images (R2)
    const maxCloudflareImageSize = 10 * 1024 * 1024; // 10MB for Cloudflare Images service
    
    const maxSize = fileType === 'video' ? maxVideoSize : maxImageSize;
    
    if (file.size > maxSize) {
      return {
        isValid: false,
        fileType,
        error: `File too large. Maximum size: ${maxSize / (1024 * 1024)}MB`,
        maxSize,
        supportedFormats: fileType === 'video' ? videoFormats : imageFormats
      };
    }

    return {
      isValid: true,
      fileType,
      maxSize,
      supportedFormats: fileType === 'video' ? videoFormats : imageFormats
    };
  }

  /**
   * Generate direct upload URL for Cloudflare Stream
   */
  async createStreamDirectUpload(metadata?: Record<string, any>): Promise<DirectUploadResponse> {
    const url = `${this.baseApiUrl}/accounts/${this.config.accountId}/stream/direct_upload`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        maxDurationSeconds: 7200, // 2 hours max
        requireSignedURLs: false,
        allowedOrigins: ['*'], // Configure based on your domain
        thumbnailTimestampPct: 0.1, // Thumbnail at 10% of video
        metadata: metadata || {}
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Stream upload URL generation failed: ${error}`);
    }

    const result = await response.json();
    return {
      uploadURL: response.headers.get('location') || result.result.uploadURL,
      uid: result.result.uid
    };
  }

  /**
   * Generate direct upload URL for Cloudflare R2
   */
  async createR2DirectUpload(fileName: string, contentType: string): Promise<DirectUploadResponse> {
    // For R2, we'll use presigned URLs (would typically be generated by a Worker)
    // This is a placeholder for the actual R2 presigned URL generation
    const key = `uploads/${Date.now()}-${fileName}`;
    
    // In production, this would call your Worker that generates R2 presigned URLs
    const workerUrl = `/api/r2-upload-url`;
    
    const response = await fetch(workerUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        key,
        contentType,
        metadata: {
          uploadedAt: new Date().toISOString(),
        }
      }),
    });

    if (!response.ok) {
      throw new Error('R2 upload URL generation failed');
    }

    const result = await response.json();
    return {
      uploadURL: result.uploadURL,
      uid: key
    };
  }

  /**
   * Generate direct upload URL for Cloudflare Images
   */
  async createImagesDirectUpload(metadata?: Record<string, any>): Promise<DirectUploadResponse> {
    const url = `${this.baseApiUrl}/accounts/${this.config.accountId}/images/v2/direct_upload`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        requireSignedURLs: false,
        metadata: metadata || {},
        expiry: new Date(Date.now() + 30 * 60 * 1000).toISOString() // 30 minutes
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Images upload URL generation failed: ${error}`);
    }

    const result = await response.json();
    return {
      uploadURL: result.result.uploadURL,
      uid: result.result.id
    };
  }

  /**
   * Upload file to the provided URL with progress tracking
   */
  async uploadFile(
    file: File, 
    uploadURL: string, 
    onProgress?: (progress: UploadProgress) => void
  ): Promise<Response> {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      // Track upload progress
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable && onProgress) {
          const progress: UploadProgress = {
            loaded: event.loaded,
            total: event.total,
            percentage: Math.round((event.loaded / event.total) * 100)
          };
          onProgress(progress);
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(new Response(xhr.responseText, { status: xhr.status }));
        } else {
          reject(new Error(`Upload failed with status ${xhr.status}: ${xhr.responseText}`));
        }
      });

      xhr.addEventListener('error', () => {
        reject(new Error('Upload failed due to network error'));
      });

      xhr.addEventListener('abort', () => {
        reject(new Error('Upload was aborted'));
      });

      // Prepare form data
      const formData = new FormData();
      formData.append('file', file);

      xhr.open('POST', uploadURL);
      xhr.send(formData);
    });
  }

  /**
   * Complete upload workflow for videos
   */
  async uploadVideo(
    file: File,
    metadata: Record<string, any> = {},
    onProgress?: (progress: UploadProgress) => void
  ): Promise<UploadResult> {
    try {
      // Validate file
      const validation = this.validateFile(file);
      if (!validation.isValid || validation.fileType !== 'video') {
        return {
          success: false,
          id: '',
          url: '',
          error: validation.error || 'Invalid video file'
        };
      }

      // Decide between Stream and R2 based on file size and use case
      const useStream = file.size <= 200 * 1024 * 1024; // Use Stream for files <= 200MB
      
      if (useStream) {
        // Use Cloudflare Stream for smaller videos
        const directUpload = await this.createStreamDirectUpload(metadata);
        await this.uploadFile(file, directUpload.uploadURL, onProgress);
        
        return {
          success: true,
          id: directUpload.uid || '',
          url: `https://customer-${this.config.streamCustomerCode}.cloudflarestream.com/${directUpload.uid}/manifest/video.m3u8`,
          thumbnailUrl: `https://customer-${this.config.streamCustomerCode}.cloudflarestream.com/${directUpload.uid}/thumbnails/thumbnail.jpg`
        };
      } else {
        // Use R2 for larger videos
        const directUpload = await this.createR2DirectUpload(file.name, file.type);
        await this.uploadFile(file, directUpload.uploadURL, onProgress);
        
        return {
          success: true,
          id: directUpload.uid || '',
          url: `https://pub-${this.config.r2BucketName}.r2.dev/${directUpload.uid}`,
          thumbnailUrl: `https://pub-${this.config.r2BucketName}.r2.dev/${directUpload.uid}-thumbnail.jpg`
        };
      }
    } catch (error) {
      return {
        success: false,
        id: '',
        url: '',
        error: error instanceof Error ? error.message : 'Upload failed'
      };
    }
  }

  /**
   * Complete upload workflow for images
   */
  async uploadImage(
    file: File,
    metadata: Record<string, any> = {},
    onProgress?: (progress: UploadProgress) => void
  ): Promise<UploadResult> {
    try {
      // Validate file
      const validation = this.validateFile(file);
      if (!validation.isValid || validation.fileType !== 'image') {
        return {
          success: false,
          id: '',
          url: '',
          error: validation.error || 'Invalid image file'
        };
      }

      // Decide between Cloudflare Images and R2 based on file size
      const useCloudflareImages = file.size <= 10 * 1024 * 1024; // Use Images service for files <= 10MB
      
      if (useCloudflareImages) {
        // Use Cloudflare Images for smaller images (with automatic optimization)
        const directUpload = await this.createImagesDirectUpload(metadata);
        await this.uploadFile(file, directUpload.uploadURL, onProgress);
        
        return {
          success: true,
          id: directUpload.uid || '',
          url: `https://imagedelivery.net/${this.config.imagesAccountHash}/${directUpload.uid}/public`,
          variants: [
            { id: 'thumbnail', url: `https://imagedelivery.net/${this.config.imagesAccountHash}/${directUpload.uid}/thumbnail` },
            { id: 'medium', url: `https://imagedelivery.net/${this.config.imagesAccountHash}/${directUpload.uid}/medium` },
            { id: 'large', url: `https://imagedelivery.net/${this.config.imagesAccountHash}/${directUpload.uid}/large` }
          ]
        };
      } else {
        // Use R2 for larger images
        const directUpload = await this.createR2DirectUpload(file.name, file.type);
        await this.uploadFile(file, directUpload.uploadURL, onProgress);
        
        return {
          success: true,
          id: directUpload.uid || '',
          url: `https://pub-${this.config.r2BucketName}.r2.dev/${directUpload.uid}`
        };
      }
    } catch (error) {
      return {
        success: false,
        id: '',
        url: '',
        error: error instanceof Error ? error.message : 'Upload failed'
      };
    }
  }

  /**
   * Get upload status for Stream videos
   */
  async getStreamUploadStatus(uid: string): Promise<any> {
    const url = `${this.baseApiUrl}/accounts/${this.config.accountId}/stream/${uid}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${this.config.apiToken}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to get upload status');
    }

    return response.json();
  }

  /**
   * Extract video metadata after upload
   */
  async extractVideoMetadata(uid: string): Promise<{
    duration: number;
    width: number;
    height: number;
    size: number;
  } | null> {
    try {
      const status = await this.getStreamUploadStatus(uid);
      const meta = status.result.meta;
      
      return {
        duration: meta.duration || 0,
        width: meta.width || 0,
        height: meta.height || 0,
        size: meta.size || 0
      };
    } catch (error) {
      console.error('Failed to extract video metadata:', error);
      return null;
    }
  }
}

// Initialize the service with environment variables
export const cloudflareUploadService = new CloudflareUploadService({
  accountId: import.meta.env.STREAM_ACCOUNT_ID || import.meta.env.PUBLIC_CLOUDFLARE_STREAM_CUSTOMER_CODE || '',
  apiToken: import.meta.env.STREAM_API_TOKEN || '',
  r2BucketName: import.meta.env.CLOUDFLARE_R2_BUCKET || 'bcd-media',
  streamCustomerCode: import.meta.env.PUBLIC_CLOUDFLARE_STREAM_CUSTOMER_CODE || '',
  imagesAccountHash: import.meta.env.PUBLIC_CLOUDFLARE_IMAGES_ACCOUNT_HASH || ''
});